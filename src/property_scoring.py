"""
property scoring code

**Note that what `calculate_fod()` did has already written in SQL query code**

Self-defined parameters:
    - The relative weight of promotion experience, spec_kols and degree of robustness
    - Specific KOLs choosen by the client
    - The number of promotion experience, generated by `np.random.randint(0, 11)`

Calculate score:
    - Compress the stdev and experience of promotion to [0, 1]

The final score is calculated by:
    - 0.5 * promotion experience score + 0.5 * stdev score
"""
import warnings
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from .utils import load_data, min_max_scaler, inverse_min_max_scaler

warnings.filterwarnings('ignore')

class PropertyScoring:
    """
    Class of property scoring
    
    Parameters:
    ----------
    - path: str
        path of scoring data
    
    Attributes:
    ----------
    - scoring_data: pd.DataFrame
        Full scoring data with 62 columns

    - scaled_data: pd.DataFrame
        Scaled voice by min_max_scaler() with 6 columns

    - org_data: pd.DataFrame
        Average post voice of 6 months with 6 columns and 1 promo_exp column
    """
    def __init__(self, path: str, w1: float, w2: float) -> None:
        self.scoring_data = load_data(path)
        self.scoring_data['promo_exp'] = np.random.randint(0, 11, size=len(self.scoring_data))
        self.scaled_data = self.scoring_data[
            [
                'scaled_voice_m1',
                'scaled_voice_m2',
                'scaled_voice_m3',
                'scaled_voice_m4',
                'scaled_voice_m5',
                'scaled_voice_m6'
            ]
        ]
        self.org_data = self.scoring_data[
            [
                'name',
                'platform',
                'avg_post_voice_1m',
                'avg_post_voice_2m',
                'avg_post_voice_3m',
                'avg_post_voice_4m',
                'avg_post_voice_5m',
                'avg_post_voice_6m',
                'promo_exp'
            ]
        ]
        self.w1, self.w2 = w1, w2


    @staticmethod
    def calculate_fod(dat: pd.DataFrame) -> list:
        """
        Calculate the first-order difference of scaled data / original data
        
        **The effect of this function has done in the SQL query code**

        Parameters
        ----------
        dat: pd.DataFrame
            scaled data
        """
        diff = dat.diff(axis=1).fillna(0)
        diff['stdev'] = diff.std(axis=1)
        stdev_arr = np.expand_dims(np.array(diff['stdev']), axis=1)
        diff['score_stdev'] = min_max_scaler(stdev_arr).flatten()
        return diff


    def plot_distribution(
            self, dat: pd.DataFrame,
            feat1: str, feat2: str
        ) -> None:
        """
        Plot the distribution of score

        Parameters
        ----------
        dat: pd.DataFrame
            scaled data
        """
        plt.figure(figsize=(12, 4))
        plt.subplot(1, 2, 1)
        plt.hist(dat[feat1], bins=20, alpha=0.5, label=feat1)
        plt.title(f"Histogram of {feat1}")

        plt.subplot(1, 2, 2)
        plt.hist(dat[feat2], bins=20, alpha=0.5, label=feat2)
        plt.title(f"Histogram of {feat2}")

        plt.tight_layout()
        plt.show()


    def main(self, dat: pd.DataFrame) -> pd.DataFrame:
        """
        main function

        Parameters
        ----------
        dat: pd.DataFrame
            scaled data
        """
        new_data = self.org_data.iloc[dat.index]
        exp_arr = np.expand_dims(np.array(new_data['promo_exp']), axis=1)
        new_data['score_promo_exp'] = inverse_min_max_scaler(exp_arr).flatten()
        new_data[['stdev', 'score_stdev']] = dat[['stdev', 'score_stdev']]
        new_data['rank'] = self.w1 * new_data['score_promo_exp'] + self.w2 * new_data['score_stdev']
        new_data['rank'] = new_data['rank'].rank(ascending=False).astype(int)
        ## self.plot_distribution(new_data, 'score_promo_exp', 'score_stdev')
        return new_data
